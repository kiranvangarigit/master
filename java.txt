difference between database and databaseserver

datbase: 
	-collection of objects
database server:
	-collection of data bases
---------------------------------------------------
STREAM APIS

Introduced in Java 8, the Stream API is used to process collections of objects. A stream is a sequence of objects that supports various methods which can be pipelined to produce the desired result.
The features of Java stream are –

A stream is not a data structure instead it takes input from the Collections, Arrays or I/O channels.
Streams don’t change the original data structure, they only provide the result as per the pipelined methods.
Each intermediate operation is lazily executed and returns a stream as a result, hence various intermediate operations can be pipelined. Terminal operations mark the end of the stream and return the result.
Different Operations On Streams-
Intermediate Operations:

map: The map method is used to returns a stream consisting of the results of applying the given function to the elements of this stream.
List number = Arrays.asList(2,3,4,5);
List square = number.stream().map(x->x*x).collect(Collectors.toList());

filter: The filter method is used to select elements as per the Predicate passed as argument.
List names = Arrays.asList("Reflection","Collection","Stream");
List result = names.stream().filter(s->s.startsWith("S")).collect(Collectors.toList());

sorted: The sorted method is used to sort the stream.
List names = Arrays.asList("Reflection","Collection","Stream");
List result = names.stream().sorted().collect(Collectors.toList());

Terminal Operations:
collect: The collect method is used to return the result of the intermediate operations performed on the stream.
List number = Arrays.asList(2,3,4,5,3);
Set square = number.stream().map(x->x*x).collect(Collectors.toSet());

forEach: The forEach method is used to iterate through every element of the stream.
List number = Arrays.asList(2,3,4,5);
number.stream().map(x->x*x).forEach(y->System.out.println(y));

reduce: The reduce method is used to reduce the elements of a stream to a single value.
The reduce method takes a BinaryOperator as a parameter.
List number = Arrays.asList(2,3,4,5);
int even = number.stream().filter(x->x%2==0).reduce(0,(ans,i)-> ans+i);

Here ans variable is assigned 0 as the initial value and i is added to it .

//a simple program to demonstrate the use of stream in java
import java.util.*;
import java.util.stream.*;
  
class Demo
{
  public static void main(String args[])
  {
  
    // create a list of integers
    List<Integer> number = Arrays.asList(2,3,4,5);
  
    // demonstration of map method
    List<Integer> square = number.stream().map(x -> x*x).
                           collect(Collectors.toList());
    System.out.println(square);
  
    // create a list of String
    List<String> names =
                Arrays.asList("Reflection","Collection","Stream");
  
    // demonstration of filter method
    List<String> result = names.stream().filter(s->s.startsWith("S")).
                          collect(Collectors.toList());
    System.out.println(result);
  
    // demonstration of sorted method
    List<String> show =
            names.stream().sorted().collect(Collectors.toList());
    System.out.println(show);
  
    // create a list of integers
    List<Integer> numbers = Arrays.asList(2,3,4,5,2);
  
    // collect method returns a set
    Set<Integer> squareSet =
         numbers.stream().map(x->x*x).collect(Collectors.toSet());
    System.out.println(squareSet);
  
    // demonstration of forEach method
    number.stream().map(x->x*x).forEach(y->System.out.println(y));
  
    // demonstration of reduce method
    int even =
       number.stream().filter(x->x%2==0).reduce(0,(ans,i)-> ans+i);
  
    System.out.println(even);
  }
}
Output:

[4, 9, 16, 25]
[Stream]
[Collection, Reflection, Stream]
[16, 4, 9, 25]
4
9
16
25
6

-------------------------------------------------------
1521   oracle port
3306   mysql
------------------------------------------------------
status code 
200: This code is used for a successful request.

201: For a successful request and data was created.

204: For empty response.

400: This is used for Bad Request. If you enter something wrong or you missed some required parameters, then the request would not be understood by the server, and you will get 400 status code.

401: This is used for Unauthorized Access. If the request authentication failed or the user does not have permissions for the requested operations, then you will get a 401 status code.


403: This is for Forbidden or Access Denied.

404: This will come if the Data Not Found.

405: This will come if the method not allowed or if the requested method is not supported.

500: This code is used for Internal Server Error.

503: And this code is used for Service Unavailable.

404->page notfound/file not found


200->all ok

405  method not allowed

201  create Response

500 internal server error
----------------------------------------------------------------------------------------------------------------------
spring IOC   contatiner                                                                                   @Configuration       // automatically create objects 
AnnotationConfigApplication context

Bean factory





-----------------------------------------------------------------------------------------------------------------------
git is an hosting service platform                                                                                             version control tools
			-create branch
			-create repository
			-git clone
			-git push
git commands
	-git init          
	-git clone url
	-git status     //modified files in current directory
	-git log         //commit history
	-git add -A  //add changed files into your next commit
	-git commit -m ' your message ' //commit your changes
	-git pull origin main // get uptodate from main branch
	-git push origin main // push your changes to main branch
	-git branch  // list all branches in local machine
	-git merge develop // will merge develop branch into current one
	-git branch branchname// will create new branch
	-git checkout branch name //switch from current
	-git  branch -m branchName //will rename current branch
	-git branch -d branchname //delete specified branch
	-git rm fileName  //remove file from project
	-git stash //save modified and stagged changes
	-git diff branch1 ...Branch2  //compare two difference which files exist in brach1 and branch2
--------------------------------------------------------------------------------------------------------------------------------------------------
Intermediate Operations:

map: 
	-The map method is used to returns a stream consisting of the results of applying the given function to the elements of this stream.
List number = Arrays.asList(2,3,4,5);
List square = number.stream().map(x->x*x).collect(Collectors.toList());
filter: 
	-The filter method is used to select elements as per the Predicate passed as argument.
List names = Arrays.asList("Reflection","Collection","Stream");
List result = names.stream().filter(s->s.startsWith("S")).collect(Collectors.toList());
sorted:
	- The sorted method is used to sort the stream.
List names = Arrays.asList("Reflection","Collection","Stream");
List result = names.stream().sorted().collect(Collectors.toList());

Terminal Operations:

collect:
	- The collect method is used to return the result of the intermediate operations performed on the stream.
List number = Arrays.asList(2,3,4,5,3);
Set square = number.stream().map(x->x*x).collect(Collectors.toSet());
forEach: 
	-The forEach method is used to iterate through every element of the stream.
List number = Arrays.asList(2,3,4,5);
number.stream().map(x->x*x).forEach(y->System.out.println(y));
reduce: 
	-The reduce method is used to reduce the elements of a stream to a single value.
The reduce method takes a BinaryOperator as a parameter.

List number = Arrays.asList(2,3,4,5);
int even = number.stream().filter(x->x%2==0).reduce(0,(ans,i)-> ans+i);

Here ans variable is assigned 0 as the initial value and i is added to it .

Program to demonstrate the use of Stream


//a simple program to demonstrate the use of stream in java
import java.util.*;
import java.util.stream.*;
  
class Demo
{
  public static void main(String args[])
  {
  
    // create a list of integers
    List<Integer> number = Arrays.asList(2,3,4,5);
  
    // demonstration of map method
    List<Integer> square = number.stream().map(x -> x*x).
                           collect(Collectors.toList());
    System.out.println(square);
  
    // create a list of String
    List<String> names =
                Arrays.asList("Reflection","Collection","Stream");
  
    // demonstration of filter method
    List<String> result = names.stream().filter(s->s.startsWith("S")).
                          collect(Collectors.toList());
    System.out.println(result);
  
    // demonstration of sorted method
    List<String> show =
            names.stream().sorted().collect(Collectors.toList());
    System.out.println(show);
  
    // create a list of integers
    List<Integer> numbers = Arrays.asList(2,3,4,5,2);
  
    // collect method returns a set
    Set<Integer> squareSet =
         numbers.stream().map(x->x*x).collect(Collectors.toSet());
    System.out.println(squareSet);
  
    // demonstration of forEach method
    number.stream().map(x->x*x).forEach(y->System.out.println(y));
  
    // demonstration of reduce method
    int even =
       number.stream().filter(x->x%2==0).reduce(0,(ans,i)-> ans+i);
  
    System.out.println(even);
  }
}
Output:

[4, 9, 16, 25]
[Stream]
[Collection, Reflection, Stream]
[16, 4, 9, 25]
4
9
16
25
6
Important Points/Observations:

A stream consists of source followed by zero or more intermediate methods combined together (pipelined) and a terminal method to process the objects obtained from the source as per the methods described.
Stream is used to compute elements as per the pipelined methods without altering the original value of the object.
	-git rebase branchName //put commits of current branch


-----------------------------------------------------------------------------------------------------------------------
.append //adding columns
-----------------------------------------------------------------------------------------------------------------------
j2EE java 2 enterprise edition

java jdk 

java se 8u221

eclipse  or sts  or intellij

pojos-plain old java objects
-----------------------------------------------------------------
Import project
	-Existing Maven project click Ok

Update project
	-project->right click->maven->update project

Build project

project->right click->Team ->push to git
	-project->right clicke->run as->maven install
-----------------------------------------------------------------------------------------------------------------
Repository/Service =Interface
controller =RestAPI
Entity =name,email,(getters and setters, constrcutor,superclass,ToString)

system.properties =port number and database connection

----------------------------------------------------------------

--------------------------------------------------------------------------------------------
REST API-CRUD OPERATIONS  with SQL
-sprind intializer ----> depenendancies
			       --->Spring Web
			       --->Mysql
			       --->SprindData JPA

------------------------------------------------------------------------------------------------

INTERFACE-IS THE MECHANISM OF ABSTRACT CLASS
			      ---->Spring Boot Dev tools(automatic Saving while changing code)

application.properties---->Spring data JPA DataBase Connections

server.port=8081
spring.datasource.plateform=mysql
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/sample_schema
spring.datasource.username=root
spring.datasource.password=root
spring.jpa.hibernate.ddl-auto=update                      (it will update the sql queries)
spring.jpa.show-sql=true                                            (it will show which query is executing)


-Create package( for Entity)
package com.example.demoForJpa.entity;
import javax.persistence.Entity;

@Entity
public class Student{

@Id                                                                                   (primary key)
GeneratedValue(stragey=GenerationType.Auto)      (Automatically incremented by one)
private long id;
private String studentName;
private String studentEmail;
private string studentAdress;

Source
-------------------------------------------------------------------------------------------------------------
Spring Boot Main annotations

@id                              primary key
@Table                       To change table name
@AutoWired             It will automatically create an object whenever it required
@RestController       Controller annotation
--------------------------------------------------
1. @SpringBootApplication
2. @ComponentScan
3. @EanbleAutoConfiguration
4. @Configuration

Stereotype annotation
----------------------------------------
1.  @Component
		-it will create a object to a bean component and registered on a spring container     or we can declare bean in xml format.
2.  @Service
3.  @RestController / @Controller
4.  @Repository

Spring Core related Annotations:
----------------------------------------------------

 @Transient    //ignoring column in database
@Configuration
@Bean
@Autowired 
@Qualifier 
@Lazy 
@Value 
@PropertySource
@ConfigurationProperties 
@Profile
@Scope

REST API related Annotations:
------------------------------------------------
@RestController
@RequestMapping
@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@RequestBody 
@PathVariable
@RequestParam
@ControllerAdvice & @ExceptionHandler

Spring Data JPA related annotations:
------------------------------------------------------------
@Entity
@Table
@Column
@Transactional 
Entity class relationships 
@OnetoOne 
@OnetoMany 
@ManytoOne
@ManytoMany
          --->  getters and setters
          --->  constructor
          --->generate constructor from superClass       default constructor
          ---->to string  (Hexadecimals content  overcome )

STEP-1:CONNECTIONS
STEP-2:ENTITIES
STEP-3:INTERFACE
STEP-4:CRUD

---------------------------------------------------------------------------------------------------------------------------

----------------------------------------ENTITY=GETTER,SETTER,CONSTRUCTER,SUPER CLASS,TO STRING-------------------------------------------------------
package com.Restapi.crud.springJPA.Entity;

import org.springframework.boot.autoconfigure.web.WebProperties.Resources.Chain.Strategy;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Student {
	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	private long id;
	private String Name;
	private String Email;
	private String Adress;
	public long getId() {
		return id;
	}
	public void setId(long id) {
		this.id = id;
	}
	public String getName() {
		return Name;
	}
	public void setName(String name) {
		Name = name;
	}
	public String getEmail() {
		return Email;
	}
	public void setEmail(String email) {
		Email = email;
	}
	public String getAdress() {
		return Adress;
	}
	public void setAdress(String adress) {
		Adress = adress;
	}
	public Student() {
		super();
		// TODO Auto-generated constructor stub
	}
	@Override
	public String toString() {
		return "Student [id=" + id + ", Name=" + Name + ", Email=" + Email + ", Adress=" + Adress + "]";
	}
	public Student(long id, String name, String email, String adress) {
		super();
		this.id = id;
		Name = name;
		Email = email;
		Adress = adress;
	}
	

}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------CONTROLLER=CRUD----------------------------------------------------------

package com.Restapi.crud.springJPA.controller;

//import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import com.Restapi.crud.springJPA.Entity.Student;
import com.Restapi.crud.springJPA.Repository.StudentRepo;

@RestController
public class StudentController {
	@Autowired
	StudentRepo studentRepo;

	@PostMapping("/api/students")
	public ResponseEntity<Student> saveStudent(@RequestBody Student student) {

		return new ResponseEntity<>(studentRepo.save(student), HttpStatus.CREATED);

	}
	// To Get ALL students
//	@GetMapping("api/students")                    
//	public ResponseEntity<List<Student>> GetStudents(){
//		return new ResponseEntity<>(studentRepo.findAll(),HttpStatus.OK);
//	}

	@GetMapping("api/students/{id}")
	public ResponseEntity<Student> Getstudents(@PathVariable long id) {
		Optional<Student> student = studentRepo.findById(id);
		if (student.isPresent()) {
			return new ResponseEntity<>(student.get(), HttpStatus.OK);

		} else {

			return new ResponseEntity<>(student.get(), HttpStatus.NOT_FOUND);
		}

	}

	@PutMapping("api/students/{id}")
	public ResponseEntity<Student> updateStudent(@PathVariable long id,@RequestBody Student stud){
		Optional<Student> student= studentRepo.findById(id);
		if(student.isPresent()) {
			student.get().setName(stud.getName());
			student.get().setEmail(stud.getEmail());
			student.get().setAdress(stud.getAdress());
			return  new ResponseEntity<>(studentRepo.save(student.get()),HttpStatus.OK);
					
		}
		else {
			
			return  new ResponseEntity<>(HttpStatus.NOT_FOUND);
		}
		
		@DeleteMapping("api/students/{id}")
		public ResponseEntity<Void> Deletestudents(@PathVariable long id){
			Optional<Student> student= studentRepo.findById(id);
			if(student.isPresent()) {
				studentRepo.deleteById(id);
			
				return  new ResponseEntity<>(HttpStatus.NO_CONTENT);
						
			}
			else {
				
				return  new ResponseEntity<>(HttpStatus.NOT_FOUND);
			}
	}

}
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------SERVICE OR REPOSITORY=INTERFACE------------------------------------------------------


package com.Restapi.crud.springJPA.Repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.Restapi.crud.springJPA.Entity.Student;

public interface StudentRepo  extends JpaRepository<Student, Long> {
	

}


-----------------------------------------------------------------------------------------------------------------------------------------------------------

 

----------------------------------------------------------------------------------------------------------------------
application.properties

spring.jpa.properties.hibernate.dialect= org.hibernate.dialect.MySQL5InnoDBDialect
spring.datasource.driverClassName=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/db_vkk?useSSL=false
spring.datasource.username=root
spring.datasource.password=root

spring.jpa.hibernate.ddl-auto=create

spring.jpa.show-sql=true

server.port=9080
---------------------------------------------------------------------------------

hibernate is a jpa provider
methods
       -flush(),persist(),merge(),remove(),contians(),find()

spring jpa is not a jpa provider
methods
       -flush(),saveAndFlush(s),save(s),delete(T),delete(ID),findOne(ID),
	exists(ID),Count(),findAll(...),anyQueryMethod(...)

TypedQuery
	-getSingleResult(),getResultList()
--------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------
Spring Intilizer
mvnRepository

sysyout   ->


ctrl+shift+f  ->format

alt+shift+s   ->getter setter  constructor

dataSource=>4 files:	1.driver class name
			2.url
			3.username
			4.password

jpa->java persistance Api                                  
orm->object relational mapping

hibernate,ibatis,toplink by using this we can orm application

jpa standards use hibernate,ibatis,toplinks we switch ibatis to hibernate

Kafka  and RabbitMQ are messaging servers


main->newfolder->rename=resources/META-INF->new->create xml file
			
static method
	     -to call simply use class name

constructor
	  -create class name same as method name
	  -create class object it will directly call the constructor

method	
       -To call method create class object and call objectname.method name

private
	-we can access private methods/variables methods can acessed which is in same class

composition
	-another class objects reference is know as obects

enum
     -An enum type is a special data type that enables for a variable to be a set of predefined constants.
 The variable must be equal to one of the values that have been predefined for it. 
Common examples include compass directions (values of NORTH, SOUTH, EAST, and WEST) and the days of the week.


collections
	 -to store data in java we can use variables(store single datatype),arrays(collections of similar elements),
	   objects(collections of different elements of different data types) 
           so due to some disadvantages of these methods java introduced collection,

collections=framework
Collection=interface      (capital C in collection)
			-collection contain add(),remove(),contains(),isEmpty,addAll() etc..,
			-collection is a root interface
					        -list,set,queue,deque (java.util.collection)
map (java.util.map)
   - key value pairs (each map can atleast one value) it cannot contain duplicate keys
    HaspMap,LinkedHashMap,TreeMap.

-----------------------------To use both collection and Map (java.util.*;)-----------------------

array
     -fixed length

list
    -it doesnt have any fixed length ,this is also a array with dynamic length.

iterator
 	 -iterator is an interface that itrates elements it used to traverse the list and modify the elements
	-it has 3 methods hasNext(),(it is used to check whether next elements present or not) 
			  next(),(to print present element)
			  remove(),(remove element)
generic concepts
		-it introduced from java 1.5    <String>
 
list interface

		-List<String> al=new ArrayList<String>();
		  al.add("kiran");

LIFO
    -last in first out, which element is inserted last we delete that element only.


exception handling
		-try,catch,finally,throw,throws.
           try,catch,throw is used in methods
           throws is used in mthod signature



java 
spring boot                    spring jpa  or hibernate are sames
hibernate  framework
microservices       communication             



spring
	-it is a open source application framework loosely coupled Dependancy injection it is used to
 develop java application without server,jws application with server

loosely coupled
	     -changing the implementation does not affect user

dependancy injection
		-passing dependancy one object to another object is know dependancy injection.


spring framework features:
        -spring ioc(inversion of control)
	-spring Aop(aspect  object programming)
	-spring mvc
	-transcation management



spring features
		-Aop  aspect oriented programming
						-aop break downs entire logic into various parts i.e transction ,login and authentication
ioc container
	-core container 
	ioc,di implicty creation at run time

ioc container type:	
		-beanfactory

		-application context

controllers
	-urls
	-call service metods here

services
	-business logic
	-methods

doa(data access object)
	-database connections

entity
  

front end=request  backend=response

entity

hibernate/jdbc
	-for database connections
-------------------------------------------------------------------------------------
<----------------@annotations-------------->
@Component
class vkk     //by default it is vkk

@Component("to change class name")
class vkk     //by default it is vkk


@ComponentsScan(basePackages="com.vkk.sprinanno")// instead of bean use this to acess all classes in package

@ComponentsScan(basePackages="com.vkk.student","com.vkk.employee")// to use multiple packages

---------------------------------------------------------------------------------------------------------------------------------------------

REST-API-Crud operations

@GetMapping
@PutMapping
@PostMapping
@DeleteMapping
------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------ANNOTATIONS------------------------------------------------CLASS LEVEL,METHOD LEVEL,


----------------------------------------------------------------------------------------------------------------
Spring Boot Main annotations
--------------------------------------------------
1. @SpringBootApplication
2. @ComponentScan
3. @EanbleAutoConfiguration
4. @Configuration

Stereotype annotation                                    -OBJECT CREATION AND OBJECT DESTROY
----------------------------------------
1.  @Component
2.  @Service
3.  @RestController / @Controller
4.  @Repository

Spring Core related Annotations:
----------------------------------------------------
@Configuration
@Bean
@Autowired 
@Qualifier 
@Lazy 
@Value 
@PropertySource
@ConfigurationProperties 
@Profile
@Scope

REST API related Annotations:
------------------------------------------------
@RestController
@RequestMapping
@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@RequestBody 
@PathVariable
@RequestParam
@ControllerAdvice & @ExceptionHandler

Spring Data JPA related annotations:
------------------------------------------------------------
@Entity
@Table
@Column
@Transactional 
Entity class relationships 
@OnetoOne 
@OnetoMany 
@ManytoOne
@ManytoMany
		
----------------------------------------------------------------------------------------------------------------------------
Some of the important Java 8 features are;

forEach() method in Iterable interface
default and static methods in Interfaces
Functional Interfaces and Lambda Expressions
Java Stream API for Bulk Data Operations on Collections
Java Time API
Collection API improvements
Concurrency API improvements
Java IO improvements
Let’s have a brief look on the

----------------------------------------------------COLLECTIONS-----------------------------------------------------
INTERFACES=>

Java List vs ArrayList
		-List is an interface whereas ArrayList is the implementation class of List.

How to create List
	-The ArrayList and LinkedList classes provide the implementation of List interface. Let's see the examples to create the List:


//Creating a List of type String using ArrayList  
				-List<String> list=new ArrayList<String>();  
  
//Creating a List of type Integer using ArrayList  
				-List<Integer> list=new ArrayList<Integer>();  
  
//Creating a List of type Book using ArrayList  
				-List<Book> list=new ArrayList<Book>();  
  
//Creating a List of type String using LinkedList  
				-List<String> list=new LinkedList<String>();  


---------------Java List Example---------------------------
Let's see a simple example of List where we are using the ArrayList class as the implementation.

import java.util.*;  
public class ListExample1{  
public static void main(String args[]){  
 //Creating a List  
 List<String> list=new ArrayList<String>();  
 //Adding elements in the List  
 list.add("Mango");  
 list.add("Apple");  
 list.add("Banana");  
 list.add("Grapes");  
 //Iterating the List element using for-each loop  
 for(String fruit:list)  
  System.out.println(fruit);  
  
}  
}  
-------------------------
-------------------------How to convert Array to List---------------------------------------------------
We can convert the Array to List by traversing the array and adding the element in list one by one using list.add() method. 
Let's see a simple example to convert array elements into List.

import java.util.*;  
public class ArrayToListExample{  
public static void main(String args[]){  
//Creating Array  
String[] array={"Java","Python","PHP","C++"};  
System.out.println("Printing Array: "+Arrays.toString(array));  
//Converting Array to List  
List<String> list=new ArrayList<String>();  
for(String lang:array){  
list.add(lang);  
}  
System.out.println("Printing List: "+list);  
  
}  
}  
---------------------------------
------------------------------How to convert List to Array-------------------------------------------------
We can convert the List to Array by calling the list.toArray() method. Let's see a simple example to convert list elements into array.

import java.util.*;  
public class ListToArrayExample{  
public static void main(String args[]){  
 List<String> fruitList = new ArrayList<>();    
 fruitList.add("Mango");    
 fruitList.add("Banana");    
 fruitList.add("Apple");    
 fruitList.add("Strawberry");    
 //Converting ArrayList to Array  
 String[] array = fruitList.toArray(new String[fruitList.size()]);    
 System.out.println("Printing Array: "+Arrays.toString(array));  
 System.out.println("Printing List: "+fruitList);  
}  
}  
----------------------------------------------------Get and Set Element in List------------------------------------------------
The get() method returns the element at the given index, whereas the set() method changes or replaces the element.

import java.util.*;  
public class ListExample2{  
 public static void main(String args[]){  
 //Creating a List  
 List<String> list=new ArrayList<String>();  
 //Adding elements in the List  
 list.add("Mango");  
 list.add("Apple");  
 list.add("Banana");  
 list.add("Grapes");  
 //accessing the element    
 System.out.println("Returning element: "+list.get(1));//it will return the 2nd element, because index starts from 0  
 //changing the element  
 list.set(1,"Dates");  
 //Iterating the List element using for-each loop  
 for(String fruit:list)  
  System.out.println(fruit);  
  
 }  
}  
----------------------How to Sort List-----------------------------------------------------
There are various ways to sort the List, here we are going to use Collections.sort() method to sort the list element. 
The java.util package provides a utility class Collections which has the static method sort(). 
Using the Collections.sort() method, we can easily sort any List.


import java.util.*;  
class SortArrayList{  
 public static void main(String args[]){  
  //Creating a list of fruits  
  List<String> list1=new ArrayList<String>();  
  list1.add("Mango");  
  list1.add("Apple");  
  list1.add("Banana");  
  list1.add("Grapes");  
  //Sorting the list  
  Collections.sort(list1);  
   //Traversing list through the for-each loop  
  for(String fruit:list1)  
    System.out.println(fruit);  
      
 System.out.println("Sorting numbers...");  
  //Creating a list of numbers  
  List<Integer> list2=new ArrayList<Integer>();  
  list2.add(21);  
  list2.add(11);  
  list2.add(51);  
  list2.add(1);  
  //Sorting the list  
  Collections.sort(list2);  
   //Traversing list through the for-each loop  
  for(Integer number:list2)  
    System.out.println(number);  
 }  
   
}  
------------Output:-------------

Apple
Banana
Grapes
Mango
Sorting numbers...
1
11
21
51
---------------------------------------------------------
The HashMap class implements the Map interface. For every entry in a HashMap, a hashCode is computed and this entry is inserted
 into the bucket with the hashCode value as its index. Every entry is a key-value pair. A bucket in a HashMap may contain more than one
 entry. A good HashMap algorithm will try to uniformly distribute the elements in the HashMap. HashMap has constant time performance
 for basic retrieval, insertion, deletion, and manipulation operations. The two most important factors that affect the performance of a HashMap
 are initial capacity and load factor. The number of buckets is the capacity and the measure of when to increase this capacity is load factor.
 The HashMap is faster compared to a HashTable.

---------------------------------------------------------------
Collection Interface
The Collection interface is the interface which is implemented by all the classes in the collection framework. It declares the methods that every collection
 will have. In other words, we can say that the Collection interface builds the foundation on which the collection framework depends.


Some of the methods of Collection interface are Boolean add ( Object obj), Boolean addAll ( Collection c), void clear(), etc. which are implemented by all the subclasses of Collection interface.

List Interface
List interface is the child interface of Collection interface. It inhibits a list type data structure in which we can store the ordered collection of objects. It can have duplicate values.

List interface is implemented by the classes ArrayList, LinkedList, Vector, and Stack.

To instantiate the List interface, we must use :

List <data-type> list1= new ArrayList();  
List <data-type> list2 = new LinkedList();  
List <data-type> list3 = new Vector();  
List <data-type> list4 = new Stack();  
There are various methods in List interface that can be used to insert, delete, and access the elements from the list.


The classes that implement the List interface are given below.
----------------------------------------------------------------------------------------
ArrayList
The ArrayList class implements the List interface. It uses a dynamic array to store the duplicate element of different data types. 
The ArrayList class maintains the insertion order and is non-synchronized. The elements stored in the ArrayList class can be randomly accessed. Consider the following example.

import java.util.*;  
class TestJavaCollection1{  
public static void main(String args[]){  
ArrayList<String> list=new ArrayList<String>();//Creating arraylist  
list.add("Ravi");//Adding object in arraylist  
list.add("Vijay");  
list.add("Ravi");  
list.add("Ajay");  
//Traversing list through Iterator  
Iterator itr=list.iterator();  
while(itr.hasNext()){  
System.out.println(itr.next());  
}  
}  
}  
Output:


Ravi
Vijay
Ravi
Ajay
----------------------------------------------------------------------
LinkedList
LinkedList implements the Collection interface. It uses a doubly linked list internally to store the elements. It can store the duplicate elements. 
It maintains the insertion order and is not synchronized. In LinkedList, the manipulation is fast because no shifting is required.

Consider the following example.

import java.util.*;  
public class TestJavaCollection2{  
public static void main(String args[]){  
LinkedList<String> al=new LinkedList<String>();  
al.add("Ravi");  
al.add("Vijay");  
al.add("Ravi");  
al.add("Ajay");  
Iterator<String> itr=al.iterator();  
while(itr.hasNext()){  
System.out.println(itr.next());  
}  
}  
}  
Output:

Ravi
Vijay
Ravi
Ajay
----------------------------------------------------------------------------------
Vector
Vector uses a dynamic array to store the data elements. It is similar to ArrayList. However, It is synchronized and contains many methods that are not the part of Collection framework.

Consider the following example.

import java.util.*;  
public class TestJavaCollection3{  
public static void main(String args[]){  
Vector<String> v=new Vector<String>();  
v.add("Ayush");  
v.add("Amit");  
v.add("Ashish");  
v.add("Garima");  
Iterator<String> itr=v.iterator();  
while(itr.hasNext()){  
System.out.println(itr.next());  
}  
}  
}  
Output:

Ayush
Amit
Ashish
Garima
-------------------------------------------------------------------------
Stack
The stack is the subclass of Vector. It implements the last-in-first-out data structure, i.e., Stack. The stack contains all of the methods of Vector class
 and also provides its methods like boolean push(), boolean peek(), boolean push(object o), which defines its properties.

Consider the following example.

import java.util.*;  
public class TestJavaCollection4{  
public static void main(String args[]){  
Stack<String> stack = new Stack<String>();  
stack.push("Ayush");  
stack.push("Garvit");  
stack.push("Amit");  
stack.push("Ashish");  
stack.push("Garima");  
stack.pop();  
Iterator<String> itr=stack.iterator();  
while(itr.hasNext()){  
System.out.println(itr.next());  
}  
}  
}  
Output:


Ayush
Garvit
Amit
Ashish
-----------------------------------------------------------------------
Queue Interface
Queue interface maintains the first-in-first-out order. It can be defined as an ordered list that is used to hold the elements which are about to
 be processed. There are various classes like PriorityQueue, Deque, and ArrayDeque which implements the Queue interface.

Queue interface can be instantiated as:

Queue<String> q1 = new PriorityQueue();  
Queue<String> q2 = new ArrayDeque();  
There are various classes that implement the Queue interface, some of them are given below.
--------------------------------------------------------------------------
PriorityQueue
The PriorityQueue class implements the Queue interface. It holds the elements or objects which are to be processed by their priorities.
 PriorityQueue doesn't allow null values to be stored in the queue.

Consider the following example.

import java.util.*;  
public class TestJavaCollection5{  
public static void main(String args[]){  
PriorityQueue<String> queue=new PriorityQueue<String>();  
queue.add("Amit Sharma");  
queue.add("Vijay Raj");  
queue.add("JaiShankar");  
queue.add("Raj");  
System.out.println("head:"+queue.element());  
System.out.println("head:"+queue.peek());  
System.out.println("iterating the queue elements:");  
Iterator itr=queue.iterator();  
while(itr.hasNext()){  
System.out.println(itr.next());  
}  
queue.remove();  
queue.poll();  
System.out.println("after removing two elements:");  
Iterator<String> itr2=queue.iterator();  
while(itr2.hasNext()){  
System.out.println(itr2.next());  
}  
}  
}  
Output:

head:Amit Sharma
head:Amit Sharma
iterating the queue elements:
Amit Sharma
Raj
JaiShankar
Vijay Raj
after removing two elements:
Raj
Vijay Raj
-----------------------------------------------------------------------------------------------------
Deque Interface
Deque interface extends the Queue interface. In Deque, we can remove and add the elements from both the side. 
Deque stands for a double-ended queue which enables us to perform the operations at both the ends.

Deque can be instantiated as:

Deque d = new ArrayDeque();  
ArrayDeque
ArrayDeque class implements the Deque interface. It facilitates us to use the Deque. Unlike queue, we can add or delete the elements from both the ends.

ArrayDeque is faster than ArrayList and Stack and has no capacity restrictions.

Consider the following example.

import java.util.*;  
public class TestJavaCollection6{  
public static void main(String[] args) {  
//Creating Deque and adding elements  
Deque<String> deque = new ArrayDeque<String>();  
deque.add("Gautam");  
deque.add("Karan");  
deque.add("Ajay");  
//Traversing elements  
for (String str : deque) {  
System.out.println(str);  
}  
}  
}  
Output:

Gautam
Karan
Ajay
----------------------------------------------------------------
Set Interface
Set Interface in Java is present in java.util package. It extends the Collection interface. It represents the unordered set of elements 
which doesn't allow us to store the duplicate items. We can store at most one null value in Set. Set is implemented by HashSet, LinkedHashSet, and TreeSet.

Set can be instantiated as:

Set<data-type> s1 = new HashSet<data-type>();  
Set<data-type> s2 = new LinkedHashSet<data-type>();  
Set<data-type> s3 = new TreeSet<data-type>(); 
----------------------------------------------------------------------- 
HashSet

HashSet class implements Set Interface. It represents the collection that uses a hash table for storage. Hashing is used to store the elements in the HashSet. It contains unique items.

Consider the following example.

import java.util.*;  
public class TestJavaCollection7{  
public static void main(String args[]){  
//Creating HashSet and adding elements  
HashSet<String> set=new HashSet<String>();  
set.add("Ravi");  
set.add("Vijay");  
set.add("Ravi");  
set.add("Ajay");  
//Traversing elements  
Iterator<String> itr=set.iterator();  
while(itr.hasNext()){  
System.out.println(itr.next());  
}  
}  
}  
Output:

Vijay
Ravi
Ajay
----------------------------------------------------------------------
LinkedHashSet
LinkedHashSet class represents the LinkedList implementation of Set Interface. It extends the HashSet class and implements Set interface.
 Like HashSet, It also contains unique elements. It maintains the insertion order and permits null elements.

Consider the following example.

import java.util.*;  
public class TestJavaCollection8{  
public static void main(String args[]){  
LinkedHashSet<String> set=new LinkedHashSet<String>();  
set.add("Ravi");  
set.add("Vijay");  
set.add("Ravi");  
set.add("Ajay");  
Iterator<String> itr=set.iterator();  
while(itr.hasNext()){  
System.out.println(itr.next());  
}  
}  
}  
Output:

Ravi
Vijay
Ajay
----------------------------------------------------------------------
SortedSet Interface
SortedSet is the alternate of Set interface that provides a total ordering on its elements. The elements of the SortedSet are arranged in
 the increasing (ascending) order. The SortedSet provides the additional methods that inhibit the natural ordering of the elements.

The SortedSet can be instantiated as:

SortedSet<data-type> set = new TreeSet();  
---------------------------------------------------------------------------------------
TreeSet
Java TreeSet class implements the Set interface that uses a tree for storage. Like HashSet, TreeSet also
 contains unique elements. However, the access and retrieval time of TreeSet is quite fast. The elements 
in TreeSet stored in ascending order.

Consider the following example:

import java.util.*;  
public class TestJavaCollection9{  
public static void main(String args[]){  
//Creating and adding elements  
TreeSet<String> set=new TreeSet<String>();  
set.add("Ravi");  
set.add("Vijay");  
set.add("Ravi");  
set.add("Ajay");  
//traversing elements  
Iterator<String> itr=set.iterator();  
while(itr.hasNext()){  
System.out.println(itr.next());  
}  
}  
}  
Output:

Ajay
Ravi
Vijay
---------------------------------------------------------MAP----------------
A Map doesn't allow duplicate keys, but you can have duplicate values. HashMap and LinkedHashMap 
allow null keys and values, but TreeMap doesn't allow any null key or value.

Class	                                                       Description
HashMap
                                 HashMap is the implementation of Map, but it doesn't maintain any order.
LinkedHashMap
                                  LinkedHashMap is the implementation of Map. It inherits HashMap class. It maintains insertion order.
TreeMap
                                 TreeMap is the implementation of Map and SortedMap. It maintains ascending order.

Java Map Example: Generic (New Style)
import java.util.*;  
class MapExample2{  
 public static void main(String args[]){  
  Map<Integer,String> map=new HashMap<Integer,String>();  
  map.put(100,"Amit");  
  map.put(101,"Vijay");  
  map.put(102,"Rahul");  
  //Elements can traverse in any order  
  for(Map.Entry m:map.entrySet()){  
   System.out.println(m.getKey()+" "+m.getValue());  
  }  
 }  
}  
Output:

102 Rahul
100 Amit
101 Vijay
-------------------------------------------------------------------------------
-------------------------------Java Map Example: comparingByKey()----------------------------------
import java.util.*;  
class MapExample3{  
 public static void main(String args[]){  
Map<Integer,String> map=new HashMap<Integer,String>();          
      map.put(100,"Amit");    
      map.put(101,"Vijay");    
      map.put(102,"Rahul");   
      //Returns a Set view of the mappings contained in this map        
      map.entrySet()  
      //Returns a sequential Stream with this collection as its source  
      .stream()  
      //Sorted according to the provided Comparator  
      .sorted(Map.Entry.comparingByKey())  
      //Performs an action for each element of this stream  
      .forEach(System.out::println);  
 }  
}  
Output:

100=Amit
101=Vijay
102=Rahul
------------------------------------------------
-----------------Java Map Example: comparingByKey() in Descending Order--------------
import java.util.*;  
class MapExample4{  
 public static void main(String args[]){  
Map<Integer,String> map=new HashMap<Integer,String>();          
      map.put(100,"Amit");    
      map.put(101,"Vijay");    
      map.put(102,"Rahul");    
      //Returns a Set view of the mappings contained in this map    
      map.entrySet()  
      //Returns a sequential Stream with this collection as its source  
      .stream()  
      //Sorted according to the provided Comparator  
      .sorted(Map.Entry.comparingByKey(Comparator.reverseOrder()))  
      //Performs an action for each element of this stream  
      .forEach(System.out::println);  
 }  
}  
Output:

102=Rahul
101=Vijay
100=Amit
------------------------------------------------------------------------
-----------------Java Map Example: comparingByValue()------------------------------
import java.util.*;  
class MapExample5{  
 public static void main(String args[]){  
Map<Integer,String> map=new HashMap<Integer,String>();          
      map.put(100,"Amit");    
      map.put(101,"Vijay");    
      map.put(102,"Rahul");    
      //Returns a Set view of the mappings contained in this map    
      map.entrySet()  
      //Returns a sequential Stream with this collection as its source  
      .stream()  
      //Sorted according to the provided Comparator  
      .sorted(Map.Entry.comparingByValue())  
      //Performs an action for each element of this stream  
      .forEach(System.out::println);  
 }  
}  
Output:

100=Amit
102=Rahul
101=Vijay
---------------------------------------------------------------
-------------------Java Map Example: comparingByValue() in Descending Order-----------------------------
import java.util.*;  
class MapExample6{  
 public static void main(String args[]){  
Map<Integer,String> map=new HashMap<Integer,String>();          
      map.put(100,"Amit");    
      map.put(101,"Vijay");    
      map.put(102,"Rahul");    
     //Returns a Set view of the mappings contained in this map    
     map.entrySet()  
     //Returns a sequential Stream with this collection as its source  
     .stream()  
     //Sorted according to the provided Comparator  
     .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))  
     //Performs an action for each element of this stream  
     .forEach(System.out::println);  
 }  
}  
101=Vijay
102=Rahul
100=Amit
--------------------------------------------------------------

java is independent once compiled we can use it on any platform

jvm is independent because we can jvm is available for windows,linux,mac

--------------------------------------------------------------

we can use setters and getters methods 
				--> .get method
we can use parameterized constructions
				-->this.employee
----------------------------------------------------------------------
j2ee disvantage is EJB(enterprise java bean)

spring 5 work on java 8 or higher versions
spring 4 work on java 7
pojos--->plain old java objects 
loose coupling---->object does not depend on other object
tightly coupled--->it depend on other objects
------------------------------------modules in spring frame work------------------------------------------
core Container
	-Bean
	-core   (read the configuration fies)
	-speL (spring expression language )
	-context

Infrastructure   (Logging, security, Transcations)
	-AOP
	-Aspects
	-Instrumentation
	-Messaging

DAO(Data Acess Layer)
	-JDBC helper class
	-orm (object relational module) hibernate ,spring JPA
	-transcations	
	-oxm
	-jms(java message service)

Web Layer module -two way communication client and server
	-servlet
	-web socket
	-web
	-portlet (to open no web pages)

Instrumentation
	-supporter class

Testing
	-unit   (junit )
	-integration				
	-mock
spring.io  website for spring project
----------------------------------------------------------------------------------------------
AUTOWIRING
	-Injecting objects automatically
	-Two types
		-xml Modes=>(No, ByName, byName, byType, Constructor, autoDetect)and
		- @AutoWiring

-------------------------------------------------------------------------------------------------
Dependancy Injections types
		-1)Setter Injection
		2)Constructor Injection
		3)Interface Injection
	
 